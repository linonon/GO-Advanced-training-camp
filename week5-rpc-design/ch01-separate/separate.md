# 隔離
本質是對系統或資源進行分割，從而實現當系統發生故障時能限定傳播範圍和影響範圍

## 服務隔離
- 動靜隔離：小到CPU的cacheline false sharing、數據庫 mysql 表設計中避免bufferpool 頻繁過期，隔離動靜表；大到架構設計中的圖片、靜態資源等緩存加速。本質上都是一樣的思路，即加速/緩存訪問變換頻次小的。靜態資源和動態API分離。
    - 降低應用服務器的負載，靜態文件訪問負載全部通過CDN
    - 對象存儲費用更低
    - 海量存儲空間，無需考慮存儲框架升級
    - 靜態CDN帶寬加速，延遲低

Example：
- archive： 稿件表，表示稿件的基本信息
- archive_stat：統計表，比較高頻的更新
- 讀寫分離：主從、Replicaset、CQRS

## 輕重隔離
- 核心隔離：業務按照 Level 進行資源池劃分（L0、L1、L2）
    - 核心/非核心的故障領域差異隔離
    - 多集群，通過冗余資源來提升吞吐和容災能力

- 快慢隔離：把Server的吞吐想像成一個池，當突然洪流近來時，池子需要一定時間才能排放完，這時候其他支流在池子裡等待的時間取決於前面的排放能力，好事就會增高，對小請求產生影響。

- 熱點隔離：熱點即經常訪問的數據。很多時候我們希望統計某個熱點數據中訪問頻次最高的Top K 數據，並對其訪問進行緩存，比如：
    - 小表廣播：從 remotecache 升級為 localcache，app定時升級，甚至可以讓運營平台支持廣播刷新localcache。（atomic value）
    - 線程級別監控，通過滑動窗口的方式使用。
    - 主動預熱

## 物理隔離
- 線程隔離：通過線程池隔離，把業務進行分類並交給不同的線程池處理。這樣當某個線程池處理一種業務請求發生問題時，不會將故障擴散和影響到其他線程池，保證服務可用。（JAVA）。對GO來說，我們只需要考慮 Goroutine 總量的控制。
- 進程隔離：離線Yarn和在線K8s做離線混部（錯峰使用），之後計劃彈性公有雲配合自建IDC做到離線的混合雲架構。
- 集群隔離：邏輯上是一個應用，物理上部署多套應用，通過 cluster 區分。
